#!/usr/bin/python3

#version 1.4
#Date: 25/04/2020
#Author: Ivan Gladushko
#
#Description: 
# The script converts JSON-formated Microsoft Office Endpoint list to flatfiles compatible 
# with firewalls and other security appliances i.e. Palo Alto Networks, Cisco, etc.
#
# It's recommended (by Microsoft) to run the script hourly
#
# The output files should be directed to a location with read access within HTTP/FTP server
# that is accessible by security appliances and their External Dynamic Lists
#
# The flatfiles are generated in a common (universal) format
# It's recommended to run HTTP, FTP, SFTP and TFTP servers preferrably on a single box/container 
# to allow various systems access the flatfiles
#
# To run the script, it's recommended to use a non-system directory for 
# third-party packages, i.e. /opt, and a non-root user, i.e. user-py
#
# Example:
# myrepo.mydomain.local:/opt/o365-json-flatfile-converter.py running under user-py
#
#
#Prerequisites:
# RHEL
# sudo yum install python3
# Ubuntu
# sudo apt-get install python3


import json
import os
import urllib.request
import uuid
import re
import sys
import smtplib

from collections import defaultdict
from urllib.request import Request, urlopen
from urllib.error import URLError
from smtplib import SMTPConnectError, SMTPException


### User variables
# path where client ID and latest version number will be stored
__VersionPath__ = '/opt/o365_endpoints_clientid_latestversion.txt'
# path where flatfiles will be stored
__OutputPath__ = '/var/ftp/o365/'
# email body and subject for successful/failed outcome
__BodyFooter__ = '\nThis email was automatically generated by Python script located at myrepo.mydomain.local:/opt/o365-json-flatfile-converter.py \nThe outcome of the update is critical for O365 and Skype for Business services. \nYour PY worker is running under "user-py" user.'
__BodySuccess__ = 'Microsoft O365 Endpoint list update from https://endpoints.office.com/endpoints/worldwide is successful. '
__SubjectSuccess__ = 'O365 Endpoint list update successful'
__BodyFail__ = 'Microsoft O365 Endpoint list update from https://endpoints.office.com/endpoints/worldwide has failed. '
__SubjectFail__ = 'O365 Endpoint list update failed'
# email server details
__Server__ = 'smtpgw.mydomain.local'
__Port__ = '25'
__StartTls__ = 0
__EmailFrom__ = 'py-worker@myrepo.mydomain.local'
__EmailTo__ = 'mycompany_network_monitoring@mycompany.com'
# for multiple recipients
#__EmailTo__ = ['recipient1', 'recipient2']


### Global variables
# Tuple arrays
flatURLs = []
flatIPv4s = []
flatIPv6s = []
# Grouped tuples
TCPgroupedURLs = defaultdict(list)
UDPgroupedURLs = defaultdict(list)
TCPgroupedIPv4s = defaultdict(list)
UDPgroupedIPv4s = defaultdict(list)
TCPgroupedIPv6s = defaultdict(list)
UDPgroupedIPv6s = defaultdict(list)

# Function definitions
# Exception handling
def excHandler(excMessage):
    excType, excValue = sys.exc_info()[:2]
    print ('\nSomething went wrong, ', excMessage)
    print ('\nException details')
    print ('Exception Type: ', excType)
    print ('Exception Value: ', excValue)

# Send email funciton
def smtpSend(message):
    try:
        smtpserver = smtplib.SMTP(__Server__, __Port__)
    except:
        excMessage = 'could not contact ' + __Server__ + ':' + __Port__
        excHandler(excMessage)
    else:
        smtpserver.ehlo()
        if (__StartTls__):
            smtpserver.starttls()
        try:
            smtpserver.sendmail(__EmailFrom__, __EmailTo__, message)
        except:
            excMessage = 'could not send email'
            excHandler(excMessage)
        else:
            smtpserver.quit()
# End of Function definitions

# Test access to URL with a dummy clientID before proceeding, send an email if the test fails followed by abort
urlcheck = Request("https://endpoints.office.com/endpoints/worldwide?clientrequestid=b10c5ed1-bad1-445f-b386-b919946339a7")
try:
    response = urlopen(urlcheck)
    ResponseCode = response.getcode()
except URLError as e:
    if hasattr(e, 'reason'):
        print ('An attempt to reach server failed.')
        print ('Reason: ', e.reason)
        ReasonMsg = e.reason.reason
        __BodyFail__ = __BodyFail__ + 'An attempt to reach server failed.' + '\nReason: ' +  ReasonMsg + __BodyFooter__
        message = 'Subject: {}\n\n{}'.format(__SubjectFail__, __BodyFail__)
        smtpSend(message)
        exit()
    elif hasattr(e, 'code'):
        print ('The server couldn\'t fulfill the request.')
        print ('Error code: ', e.code)
        ErrorCode = e.code.code
        __BodyFail__ = __BodyFail__ + 'The server couldn\'t fulfill the request.'  + '\nError code: ' + ErrorCode + __BodyFooter__
        message = 'Subject: {}\n\n{}'.format(__SubjectFail__, __BodyFail__)
        smtpSend(message)
        exit()
#else:
#    print(response)

# helper to call the webservice and parse the response
def webApiGet(methodName, instanceName, clientRequestId):
    ws = "https://endpoints.office.com"
    requestPath = ws + '/' + methodName + '/' + instanceName + '?clientRequestId=' + clientRequestId
    request = urllib.request.Request(requestPath)
    with urllib.request.urlopen(request) as response:
        return json.loads(response.read().decode())

# fetch client ID and version if data exists; otherwise create new file
if os.path.exists(__VersionPath__):
    with open(__VersionPath__, 'r') as fin:
        clientRequestId = fin.readline().strip()
        latestVersion = fin.readline().strip()
else:
    clientRequestId = str(uuid.uuid4())
    latestVersion = '0000000000'
    with open(__VersionPath__, 'w') as fout:
        fout.write(clientRequestId + '\n' + latestVersion)

# call version method to check the latest version, abort the script if the call fails
version = webApiGet('version', 'Worldwide', clientRequestId)
# pull new data if version number is different
if version['latest'] > latestVersion:
    print('New version of Office 365 worldwide commercial service instance endpoints detected')
    # write the new version number to the data file
    with open(__VersionPath__, 'w') as fout:
        fout.write(clientRequestId + '\n' + version['latest'])
    # invoke endpoints method to get the new data
    endpointSets = webApiGet('endpoints', 'Worldwide', clientRequestId)
    
    # filter results for endpoints, and transform these into tuples of URLs with service, port and category
    for endpointSet in endpointSets:
        if (endpointSet['category'] in ('Default', 'Optimize', 'Allow')):
            service = endpointSet['serviceArea']
            category = endpointSet['category']
            urls = endpointSet['urls'] if 'urls' in endpointSet else []
            tcpPorts = endpointSet['tcpPorts'] if 'tcpPorts' in endpointSet else ''
            udpPorts = endpointSet['udpPorts'] if 'udpPorts' in endpointSet else ''
            flatURLs.extend([(service, category, url, tcpPorts, udpPorts) for url in urls])

    # filter results for endpoints, and transform these into tuples of IPv4s with service, port and category
    for endpointSet in endpointSets:
        if (endpointSet['category'] in ('Default', 'Optimize', 'Allow')):
            service = endpointSet['serviceArea']
            category = endpointSet['category']
            ips = endpointSet['ips'] if 'ips' in endpointSet else []
            # IPv4 strings have dots while IPv6 strings have colons
            ip4s = [ip for ip in ips if '.' in ip]
            tcpPorts = endpointSet['tcpPorts'] if 'tcpPorts' in endpointSet else ''
            udpPorts = endpointSet['udpPorts'] if 'udpPorts' in endpointSet else ''
            flatIPv4s.extend([(service, category, ip, tcpPorts, udpPorts) for ip in ip4s])

    # filter results for endpoints, and transform these into tuples of IPv6s with service, port and category
    for endpointSet in endpointSets:
        if (endpointSet['category'] in ('Default', 'Optimize', 'Allow')):
            service = endpointSet['serviceArea']
            category = endpointSet['category']
            ips = endpointSet['ips'] if 'ips' in endpointSet else []
            # IPv4 strings have dots while IPv6 strings have colons
            ip6s = [ip for ip in ips if ':' in ip]
            tcpPorts = endpointSet['tcpPorts'] if 'tcpPorts' in endpointSet else ''
            udpPorts = endpointSet['udpPorts'] if 'udpPorts' in endpointSet else ''
            flatIPv6s.extend([(service, category, ip, tcpPorts, udpPorts) for ip in ip6s])

    # Grouping URL tuples by TCP and UDP
    for service, category, url, tcpPorts, udpPorts in flatURLs:
       TCPgroupedURLs[service,tcpPorts].append(url)
       UDPgroupedURLs[service,udpPorts].append(url)
    # Joining serviceArea, type and port for filenames
    TCPURLs = TCPgroupedURLs.items()
    items = [{'area-port':a, 'urls':b} for a, b in TCPURLs]
    for item in items:
       if (item['area-port'][1]):
          item['area-port'] = 'o365_endpoints_url_' + item['area-port'][0] + '_tcp_' + re.sub(',','_',item['area-port'][1]) + '.txt'
    # Forming and filling the file with sorted and deduplicated (using "set") data
          file = open(__OutputPath__ + item['area-port'],"w+")
          file.write('\n'.join(sorted(set(item['urls'])))+'\n')
          file.close()
    # Joining serviceArea, type and port for filenames
    UDPURLs = UDPgroupedURLs.items()
    items = [{'area-port':a, 'urls':b} for a, b in UDPURLs]
    for item in items:
       if (item['area-port'][1]):
          item['area-port'] = 'o365_endpoints_url_' + item['area-port'][0] + '_udp_' + re.sub(',','_',item['area-port'][1]) + '.txt'
    # Forming and filling the file with sorted and deduplicated (using "set") data
          file = open(__OutputPath__ + item['area-port'],"w+")
          file.write('\n'.join(sorted(set(item['urls'])))+'\n')
          file.close()

    # Grouping IPv4 tuples by TCP and UDP
    for service, category, ip, tcpPorts, udpPorts in flatIPv4s:
       TCPgroupedIPv4s[service,tcpPorts].append(ip)
       UDPgroupedIPv4s[service,udpPorts].append(ip)
    # Joining serviceArea, type and port for filenames
    TCPIPv4s = TCPgroupedIPv4s.items()
    items = [{'area-port':a, 'ips':b} for a, b in TCPIPv4s]
    for item in items:
       if (item['area-port'][1]):
          item['area-port'] = 'o365_endpoints_ipv4_' + item['area-port'][0] + '_tcp_' + re.sub(',','_',item['area-port'][1]) + '.txt'
    # Forming and filling the file with sorted and deduplicated (using "set") data       
          file = open(__OutputPath__ + item['area-port'],"w+")
          file.write('\n'.join(sorted(set(item['ips'])))+'\n')
          file.close()
    # Joining serviceArea, type and port for filenames
    UDPIPv4s = UDPgroupedIPv4s.items()
    items = [{'area-port':a, 'ips':b} for a, b in UDPIPv4s]
    for item in items:
       if (item['area-port'][1]):
          item['area-port'] = 'o365_endpoints_ipv4_' + item['area-port'][0] + '_udp_' + re.sub(',','_',item['area-port'][1]) + '.txt'
    # Forming and filling the file with sorted and deduplicated (using "set") data
          file = open(__OutputPath__ + item['area-port'],"w+")
          file.write('\n'.join(sorted(set(item['ips'])))+'\n')
          file.close()

    # Grouping IPv6 tuples by TCP and UDP
    for service, category, ip, tcpPorts, udpPorts in flatIPv6s:
       TCPgroupedIPv6s[service,tcpPorts].append(ip)
       UDPgroupedIPv6s[service,udpPorts].append(ip)
    # Joining serviceArea, type and port for filenames
    TCPIPv6s = TCPgroupedIPv6s.items()
    items = [{'area-port':a, 'ips':b} for a, b in TCPIPv6s]
    for item in items:
       if (item['area-port'][1]):
          item['area-port'] = 'o365_endpoints_ipv6_' + item['area-port'][0] + '_tcp_' + re.sub(',','_',item['area-port'][1]) + '.txt'
    # Forming and filling the file with sorted and deduplicated (using "set") data
          file = open(__OutputPath__ + item['area-port'],"w+")
          file.write('\n'.join(sorted(set(item['ips'])))+'\n')
          file.close()
    # Joining serviceArea, type and port for filenames
    UDPIPv6s = UDPgroupedIPv6s.items()
    items = [{'area-port':a, 'ips':b} for a, b in UDPIPv6s]
    for item in items:
       if (item['area-port'][1]):
          item['area-port'] = 'o365_endpoints_ipv6_' + item['area-port'][0] + '_udp_' + re.sub(',','_',item['area-port'][1]) + '.txt'
    # Forming and filling the file with sorted and deduplicated (using "set") data
          file = open(__OutputPath__ + item['area-port'],"w+")
          file.write('\n'.join(sorted(set(item['ips'])))+'\n')
          file.close()
    
    # Notification printout
    print('\nThe output files have been created successfully in ', __OutputPath__)

    # Forming email body
    __BodySuccess__ = __BodySuccess__ + __BodyFooter__

    # Send mail upon successful update completion
    message = 'Subject: {}\n\n{}'.format(__SubjectSuccess__, __BodySuccess__)
    smtpSend(message)

else:
    print('Office 365 worldwide commercial service instance endpoints are up-to-date')

